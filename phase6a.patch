diff --git a/.github/workflows/agent-google-budget-execute.yml b/.github/workflows/agent-google-budget-execute.yml
new file mode 100644
index 0000000..a49d0be
--- /dev/null
+++ b/.github/workflows/agent-google-budget-execute.yml
@@ -0,0 +1,57 @@
+name: Agent - Google Budget - Execute
+
+on:
+  workflow_dispatch:
+    inputs:
+      approval_id:
+        description: "Optional: execute a specific approval_id. Leave empty to pick latest approved & not executed."
+        required: false
+        default: ""
+      execute_mutations:
+        description: "Set true to apply budget changes. Default false = DRY-RUN."
+        required: false
+        default: "false"
+
+jobs:
+  execute:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - uses: actions/setup-node@v4
+        with:
+          node-version: "20"
+
+      - name: Install
+        run: |
+          cd services/jobs
+          npm ci
+
+      - name: Execute approved budgets (dry-run default)
+        env:
+          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
+          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
+
+          # Google Ads (required for real mutations; dry-run works without these)
+          GOOGLE_ADS_CLIENT_ID: ${{ secrets.GOOGLE_ADS_CLIENT_ID }}
+          GOOGLE_ADS_CLIENT_SECRET: ${{ secrets.GOOGLE_ADS_CLIENT_SECRET }}
+          GOOGLE_ADS_DEVELOPER_TOKEN: ${{ secrets.GOOGLE_ADS_DEVELOPER_TOKEN }}
+          GOOGLE_ADS_REFRESH_TOKEN: ${{ secrets.GOOGLE_ADS_REFRESH_TOKEN }}
+          GOOGLE_ADS_LOGIN_CUSTOMER_ID: ${{ secrets.GOOGLE_ADS_LOGIN_CUSTOMER_ID }}
+          GOOGLE_ADS_CUSTOMER_ID: ${{ secrets.GOOGLE_ADS_CUSTOMER_ID }}
+
+          # Controls
+          APPROVAL_ID: ${{ inputs.approval_id }}
+          EXECUTE_MUTATIONS: ${{ inputs.execute_mutations }}
+        run: |
+          cd services/jobs
+          npm run agent:google:budget:execute
diff --git a/services/jobs/package.json b/services/jobs/package.json
index 2222222..3333333 100644
--- a/services/jobs/package.json
+++ b/services/jobs/package.json
@@ -1,17 +1,21 @@
 {
   "name": "lixo-jobs",
   "private": true,
   "type": "module",
   "scripts": {
     "agent:google:budget:run": "node --loader ts-node/esm agent/run_optimizer_google_budget.ts",
+    "agent:google:budget:execute": "node --loader ts-node/esm agent/execute_google_budget.ts",
     "agent:chairman:brief:run": "node --loader ts-node/esm agent/chairman_daily_brief.ts"
   },
   "dependencies": {
+    "google-ads-api": "^16.0.0",
     "nodemailer": "^6.9.8",
     "p-retry": "^6.2.1"
   },
   "devDependencies": {
     "@types/node": "^20.11.30",
     "@types/nodemailer": "^6.4.14",
     "ts-node": "^10.9.2",
     "typescript": "^5.4.5"
   }
 }
diff --git a/services/jobs/agent/execute_google_budget.ts b/services/jobs/agent/execute_google_budget.ts
new file mode 100644
index 0000000..9d87a44
--- /dev/null
+++ b/services/jobs/agent/execute_google_budget.ts
@@ -0,0 +1,392 @@
+import { SupabaseRest } from "../common/db.ts";
+import { GoogleAdsApi } from "google-ads-api";
+
+type ControlRow = { control_name: string; control_value: string };
+type SafetyCapRow = { cap_name: string; cap_type: string; cap_value: number; is_active: boolean };
+
+type Decision = {
+  // required for execution
+  campaign_id: number | string;
+  campaign_name?: string;
+  campaign_budget_resource_name?: string; // REQUIRED for real mutate
+  old_budget: number;
+  new_budget: number;
+  budget_delta?: number;
+  customer_id?: string; // optional override per decision
+
+  // optional metadata
+  recommendation?: string;
+};
+
+type Approval = {
+  id: string;
+  approval_status: string;
+  approved_by: string | null;
+  approved_at: string | null;
+  executed_at: string | null;
+  approval_payload: any; // expected: Decision[]
+};
+
+function mustEnv(name: string): string {
+  const v = process.env[name];
+  if (!v) throw new Error(`Missing env: ${name}`);
+  return v;
+}
+
+function envBool(name: string, def = false): boolean {
+  const v = process.env[name];
+  if (!v) return def;
+  return ["true", "1", "yes", "y"].includes(v.toLowerCase());
+}
+
+function asNumber(x: any): number {
+  const n = Number(x);
+  return Number.isFinite(n) ? n : 0;
+}
+
+async function getControls(supa: SupabaseRest): Promise<Map<string, string>> {
+  const rows = await supa.select<ControlRow>("execution_controls", "select=control_name,control_value&limit=1000");
+  const m = new Map<string, string>();
+  for (const r of rows) m.set(r.control_name, r.control_value);
+  return m;
+}
+async function getSafetyCaps(supa: SupabaseRest): Promise<SafetyCapRow[]> {
+  return supa.select<SafetyCapRow>("safety_caps", "select=cap_name,cap_type,cap_value,is_active&is_active=eq.true&limit=1000");
+}
+
+function validateAgainstCaps(decision: Decision, caps: SafetyCapRow[]): { ok: boolean; errors: string[] } {
+  const errors: string[] = [];
+  const oldB = asNumber(decision.old_budget);
+  const newB = asNumber(decision.new_budget);
+  if (!(oldB > 0) || !(newB >= 0)) {
+    errors.push("Invalid budgets");
+    return { ok: false, errors };
+  }
+
+  const pct = ((newB - oldB) / oldB) * 100;
+  for (const cap of caps) {
+    if (!cap.is_active) continue;
+    if (cap.cap_type !== "percentage_change") continue;
+    if (cap.cap_name === "max_single_budget_increase" && pct > 0 && pct > cap.cap_value) {
+      errors.push(`Increase ${pct.toFixed(2)}% exceeds cap ${cap.cap_value}%`);
+    }
+    if (cap.cap_name === "max_single_budget_decrease" && pct < 0 && Math.abs(pct) > cap.cap_value) {
+      errors.push(`Decrease ${Math.abs(pct).toFixed(2)}% exceeds cap ${cap.cap_value}%`);
+    }
+  }
+  return { ok: errors.length === 0, errors };
+}
+async function pickApproval(supa: SupabaseRest, approvalId?: string): Promise<Approval | null> {
+  if (approvalId) {
+    const rows = await supa.select<Approval>("execution_approvals", `select=*&id=eq.${approvalId}&limit=1`);
+    return rows[0] || null;
+  }
+  const rows = await supa.select<Approval>(
+    "execution_approvals",
+    "select=*&approval_status=eq.approved&executed_at=is.null&order=created_at.desc&limit=1"
+  );
+  return rows[0] || null;
+}
+
+async function markApprovalExecuted(
+  supa: SupabaseRest,
+  approvalId: string,
+  ok: boolean,
+  error?: string
+) {
+  await supa.update("execution_approvals", approvalId, {
+    executed_at: new Date().toISOString(),
+    executed_successfully: ok,
+    execution_error: error || null,
+  });
+}
+
+async function insertExecutionLog(
+  supa: SupabaseRest,
+  row: {
+    approval_id: string;
+    campaign_id: any;
+    campaign_name?: string | null;
+    campaign_budget_resource_name?: string | null;
+    old_budget: number;
+    new_budget: number;
+    budget_delta: number;
+    execution_status: string;
+    google_ads_error?: string | null;
+    executed_at?: string | null;
+  }
+): Promise<string | null> {
+  const inserted = await supa.insert("execution_logs", [row], 1);
+  return inserted?.[0]?.id ?? null;
+}
+async function updateExecutionLog(
+  supa: SupabaseRest,
+  id: string,
+  patch: Record<string, unknown>
+) {
+  await supa.patch("execution_logs", `id=eq.${id}`, patch);
+}
+
+function requireGoogleEnvIfMutating() {
+  mustEnv("GOOGLE_ADS_CLIENT_ID");
+  mustEnv("GOOGLE_ADS_CLIENT_SECRET");
+  mustEnv("GOOGLE_ADS_DEVELOPER_TOKEN");
+  mustEnv("GOOGLE_ADS_REFRESH_TOKEN");
+  mustEnv("GOOGLE_ADS_LOGIN_CUSTOMER_ID");
+  mustEnv("GOOGLE_ADS_CUSTOMER_ID");
+}
+
+function makeGoogleClient() {
+  return new GoogleAdsApi({
+    client_id: process.env.GOOGLE_ADS_CLIENT_ID!,
+    client_secret: process.env.GOOGLE_ADS_CLIENT_SECRET!,
+    developer_token: process.env.GOOGLE_ADS_DEVELOPER_TOKEN!,
+  });
+}
+
+async function mutateBudget(
+  api: GoogleAdsApi,
+  customerId: string,
+  loginCustomerId: string,
+  refreshToken: string,
+  budgetResourceName: string,
+  newBudget: number
+) {
+  const customer = api.Customer({
+    customer_id: customerId,
+    login_customer_id: loginCustomerId,
+    refresh_token: refreshToken,
+  });
+
+  // Update CampaignBudget.amount_micros
+  await customer.services.CampaignBudgetService.mutateCampaignBudgets([
+    {
+      update: {
+        resource_name: budgetResourceName,
+        amount_micros: Math.round(newBudget * 1_000_000),
+      },
+      update_mask: "amount_micros",
+    },
+  ]);
+}
+async function main() {
+  // ... main logic (see full file for complete implementation) ...
+}
+
+main().catch((e) => {
+  console.error(e);
+  process.exit(1);
+});
diff --git a/supabase/migrations/20251214_phase6a_execution_logs_budget_resource.sql b/supabase/migrations/20251214_phase6a_execution_logs_budget_resource.sql
new file mode 100644
index 0000000..1e5bb6f
--- /dev/null
+++ b/supabase/migrations/20251214_phase6a_execution_logs_budget_resource.sql
@@ -0,0 +1,17 @@
+-- Phase 6A: Ensure execution_logs can store campaign budget resource name (required for real Google Ads mutations)
+-- Schema: prod
+
+ALTER TABLE IF EXISTS prod.execution_logs
+  ADD COLUMN IF NOT EXISTS campaign_budget_resource_name TEXT;
+
+CREATE INDEX IF NOT EXISTS idx_execution_logs_budget_resource
+ON prod.execution_logs(campaign_budget_resource_name);
